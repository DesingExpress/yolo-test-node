{"ast":null,"code":"import labels from \"./labels.json\";\n\n/**\n * Render prediction boxes\n * @param {HTMLCanvasElement} canvasRef canvas tag reference\n * @param {Array} boxes_data boxes array\n * @param {Array} scores_data scores array\n * @param {Array} classes_data class array\n * @param {Array[Number]} ratios boxes ratio [xRatio, yRatio]\n */\nexport const renderBoxes = (canvasRef, boxes_data, scores_data, classes_data, ratios) => {\n  const ctx = canvasRef.getContext(\"2d\");\n  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); // clean canvas\n\n  const colors = new Colors();\n\n  // font configs\n  const font = `${Math.max(Math.round(Math.max(ctx.canvas.width, ctx.canvas.height) / 40), 14)}px Arial`;\n  ctx.font = font;\n  ctx.textBaseline = \"top\";\n  for (let i = 0; i < scores_data.length; ++i) {\n    // filter based on class threshold\n    const klass = labels[classes_data[i]];\n    const color = colors.get(classes_data[i]);\n    const score = (scores_data[i] * 100).toFixed(1);\n    let [y1, x1, y2, x2] = boxes_data.slice(i * 4, (i + 1) * 4);\n    x1 *= ratios[0];\n    x2 *= ratios[0];\n    y1 *= ratios[1];\n    y2 *= ratios[1];\n    const width = x2 - x1;\n    const height = y2 - y1;\n\n    // draw box.\n    ctx.fillStyle = Colors.hexToRgba(color, 0.2);\n    ctx.fillRect(x1, y1, width, height);\n\n    // draw border box.\n    ctx.strokeStyle = color;\n    ctx.lineWidth = Math.max(Math.min(ctx.canvas.width, ctx.canvas.height) / 200, 2.5);\n    ctx.strokeRect(x1, y1, width, height);\n\n    // Draw the label background.\n    ctx.fillStyle = color;\n    const textWidth = ctx.measureText(klass + \" - \" + score + \"%\").width;\n    const textHeight = parseInt(font, 10); // base 10\n    const yText = y1 - (textHeight + ctx.lineWidth);\n    ctx.fillRect(x1 - 1, yText < 0 ? 0 : yText,\n    // handle overflow label box\n    textWidth + ctx.lineWidth, textHeight + ctx.lineWidth);\n\n    // Draw labels\n    ctx.fillStyle = \"#ffffff\";\n    ctx.fillText(klass + \" - \" + score + \"%\", x1 - 1, yText < 0 ? 0 : yText);\n  }\n};\nconst Colors = /*#__PURE__*/(() => {\n  class Colors {\n    // ultralytics color palette https://ultralytics.com/\n    constructor() {\n      this.get = i => this.palette[Math.floor(i) % this.n];\n      this.palette = [\"#FF3838\", \"#FF9D97\", \"#FF701F\", \"#FFB21D\", \"#CFD231\", \"#48F90A\", \"#92CC17\", \"#3DDB86\", \"#1A9334\", \"#00D4BB\", \"#2C99A8\", \"#00C2FF\", \"#344593\", \"#6473FF\", \"#0018EC\", \"#8438FF\", \"#520085\", \"#CB38FF\", \"#FF95C8\", \"#FF37C7\"];\n      this.n = this.palette.length;\n    }\n  }\n  Colors.hexToRgba = (hex, alpha) => {\n    var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    return result ? `rgba(${[parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)].join(\", \")}, ${alpha})` : null;\n  };\n  return Colors;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}